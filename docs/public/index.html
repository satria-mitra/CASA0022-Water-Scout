<!DOCTYPE html>
<html lang="en">
<head>
  <title>My A-Frame Scene with Water Gauge and D3.js Chart</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
  <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
  <a-scene>
    <a-entity 
      id="housemill"
      gltf-model="./src/models/housemill_test.gltf" 
      position="0 0 0" 
      scale="3 3 3"
      replace-planes-with-water>
    </a-entity>
    
    <a-entity 
      id="water-gauge"
      gltf-model="./src/models/water_gauge.gltf" 
      position="-18 -3.1 -12" 
      scale="100 100 100">
    </a-entity>
    
    <a-plane id="chart-plane" position="-24 15 -2" width="15" height="10" color="#FFF" rotation="320 185 0"></a-plane>

    <a-sky color="lightblue"></a-sky>

    <a-entity 
      camera 
      look-controls="enabled: false" 
      orbit-controls="target:-10 10 15; minDistance: 2; maxDistance: 180; initialPosition: 5 20 -35; rotateSpeed: 0.5">
    </a-entity>
  </a-scene>

  <canvas id="chartCanvas" width="1024" height="512" style="display:none;"></canvas>

  <script>
    const waterNormalsPath = './src/textures/waternormals.jpg';

    AFRAME.registerComponent('replace-planes-with-water', {
      init: async function () {
        const scene = this.el.sceneEl.object3D;

        console.log("Initializing water component");

        const waterHeightData = await fetch('/latest-water-height').then(res => res.json());
        const waterHeightValue = waterHeightData._value * -1 + 4500;

        const waterPlaneWidth = 63; 
        const waterPlaneLength = 28; 
        const yPosition = 0.001 * waterHeightValue - 3.3;
        const waterPlanePosition = new THREE.Vector3(7, yPosition, -13);

        const waterObjects = await ReplacePlanesWithWater(scene, waterPlaneWidth, waterPlaneLength, waterPlanePosition);

        console.log("Water objects created:", waterObjects);

        this.el.sceneEl.addEventListener('renderstart', function () {
          scene.onBeforeRender = () => {
            waterObjects.forEach(animateWater);
          };
        });

        fetchAndRenderChart();
      }
    });

    async function fetchAndRenderChart() {
      const chartData = await fetch('/water-height-last-2-days').then(res => res.json());

      const data = chartData.map(d => ({
        label: new Date(d.time),
        value: d.value * -1 + 4500,
      }));

      console.log('Chart Data:', data);

      renderD3Chart(data);
    }

    function renderD3Chart(data) {
      const canvas = document.getElementById('chartCanvas');
      const ctx = canvas.getContext('2d');
    
      // Clear the canvas before drawing
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      // Draw the title
      ctx.fillStyle = 'black';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Water Height Dashboard', canvas.width / 2, 40);
    
      // D3.js scales for X and Y axes with increased margin
      const margin = { top: 70, right: 120, bottom: 70, left: 80 };
      const width = canvas.width - margin.left - margin.right;
      const height = canvas.height - margin.top - margin.bottom;
    
      const x = d3.scaleTime()
                  .domain(d3.extent(data, d => d.label))
                  .range([margin.left, width + margin.left]);
    
      const y = d3.scaleLinear()
                  .domain([0, d3.max(data, d => d.value)])
                  .range([height + margin.top, margin.top]);
    
      // Define the threshold value
      const thresholdValue = 1500; // Set your desired threshold value here
      
      // Draw the threshold line
      const thresholdY = y(thresholdValue);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(margin.left, thresholdY);
      ctx.lineTo(width + margin.left, thresholdY);
      ctx.stroke();
    
      // Draw the threshold label
      ctx.fillStyle = 'red';
      ctx.font = '14px Arial';
      ctx.fillText(`Threshold: ${thresholdValue}`, margin.left + 10, thresholdY - 10);
    
      // Draw the data line
      ctx.strokeStyle = 'steelblue';
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((d, i) => {
        const xPos = x(d.label);
        const yPos = y(d.value);
        if (i === 0) {
          ctx.moveTo(xPos, yPos);
        } else {
          ctx.lineTo(xPos, yPos);
        }
        ctx.fillStyle = 'black';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(d.value.toFixed(2), xPos, yPos - 10);
      });
      ctx.stroke();
    
      // Draw X axis with 2-hour interval
      ctx.strokeStyle = '#000';
      ctx.fillStyle = 'black';
      ctx.beginPath();
    
      const tickInterval = d3.timeHour.every(2); // Custom tick interval, every 2 hours
      x.ticks(tickInterval).forEach((tick, i) => {
        const xPos = x(tick);
        ctx.moveTo(xPos, height + margin.top);
        ctx.lineTo(xPos, height + margin.top + 5);
        ctx.save();
        ctx.translate(xPos, height + margin.top + 25);
        ctx.rotate(-Math.PI / 4);
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(d3.timeFormat("%b %d %H:%M")(tick), 0, 0);
        ctx.restore();
      });
      ctx.stroke();
    
      // Label for X-axis
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Time', width / 2 + margin.left, height + margin.top + 50);
    
      // Draw Y axis
      ctx.beginPath();
      y.ticks().forEach(tick => {
        const yPos = y(tick);
        ctx.moveTo(margin.left - 5, yPos);
        ctx.lineTo(margin.left, yPos);
        ctx.fillText(tick, margin.left - 10, yPos + 5);
      });
      ctx.stroke();
    
      // Label for Y-axis
      ctx.save();
      ctx.translate(margin.left - 50, height / 2 + margin.top);
      ctx.rotate(-Math.PI / 2);
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Water Height (mm)', 0, 0);
      ctx.restore();
    
      // Draw Legend
      const legendX = width + margin.left + 20;
      const legendY = margin.top;
      const lineHeight = 30;
    
      ctx.fillStyle = 'red';
      ctx.fillRect(legendX, legendY, 20, 2);
      ctx.fillStyle = 'black';
      ctx.font = '14px Arial';
      ctx.fillText('Threshold', legendX + 30, legendY + 5);
    
      ctx.strokeStyle = 'steelblue';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(legendX, legendY + lineHeight);
      ctx.lineTo(legendX + 20, legendY + lineHeight);
      ctx.stroke();
      ctx.fillText('Water Height', legendX + 30, legendY + lineHeight + 5);
    
      // Convert the D3 chart into a texture and apply it to the plane
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
    
      const plane = document.getElementById('chart-plane');
      plane.setAttribute('material', 'src', texture);
    }
    

    async function ReplacePlanesWithWater(scene, width, length, position) {
      const waterObjects = [];
      const water = await createManualWaterPlane(width, length, position, scene);
      waterObjects.push(water);
      scene.add(water);
      return waterObjects;
    }

    async function createManualWaterPlane(width, length, position, scene) {
      return new Promise((resolve) => {
        const waterGeometry = new THREE.PlaneGeometry(width, length);
        new THREE.TextureLoader().load(waterNormalsPath, (texture) => {
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          const water = new THREE.Water(waterGeometry, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: texture,
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x00faff,
            distortionScale: 3.7,
            fog: scene.fog !== undefined,
          });
          water.rotation.x = -Math.PI / 2;
          water.position.copy(position);
          resolve(water);
        });
      });
    }

    function animateWater(water) {
      if (water && water.material && water.material.uniforms && water.material.uniforms['time']) {
        water.material.uniforms['time'].value += 1.0 / 100.0;
      } else {
        console.warn('Water uniforms not set properly:', water.material.uniforms);
      }
    }
  </script>
</body>
</html>
